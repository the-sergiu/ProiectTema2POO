
-- Cerinta initiala (de proiect); 5p/100

Implementati ierarhia de clase pentru produsele din magazin, pronind de la diagrama *diagrama UML*. Ce constructori, operatori si alte metode sunt necesare? Nu uitati de get-eri si set-eri! ?? Atentie, nu vor exista obiecte de tip Product, ci doar subtipuri. ??

Acesta este un exercitiu pentru a va antrena in conceperea unei ierarhii de clase.

-- Tema propriu-zisa
( Sunt date fisierele .h, ce contin tipurile datelor si declararea functiilor necesare (pe care le vor implementa in .cpp) )

-- Implementati metodele descrise/necesare ierarhiei de produse. (Checker-ul verifica clasele)
Pentru implentarea corecta a claselor, de nota 5 (50/100 p)
* Pentru a testa clasele (de unele singure), commentati #include-ul claselor pe care nu intentionati sa le utilizati.

Initializati serverul. Listele de useri si produse sunt initializate folosind functii deja create, pentru a evita citirea din fisiere. Dupa acest pas, creati map-urile stocate pe server.

-- CERINTE
2. 2 tipuri de cautari/interogari/cerinte pentru manipularea datelor de pe server (folosind map-uri si listele de obiecte)
    
    a. George are nevoie de un espressor nou. Fiind inainte de salariu, George cauta un produs redus. Astfel, cautati in lista de produse espressoarele reduse si returnati lista cu aceste produse (VALID - GetCategorie?)

    b. Returnati o lista cu utilizatorii nonpremium care au un cost de transport < 11.5 lei. (VALID)

    c. Gasiti toate produsele returnate si resigilate pe motivul "x". Sortati-le dupa price si salvati lista neomogena in fisierul de output.

    d. Sortare produse alimentare dupa name, tara, price

    e. Returnati o lista cu userii care au atat adresa de livrare, cat si cea de facturare la casa (adica nu la bloc) si locuiesc in judetul cu cei mai multi utilizatori. Sortati dupa UserID (VALID - problema sortare)

    f. Returnati o lista cu toti utilizatorii premium care au cupoane de reducere pentru telefoane sau imprimante. (VALID - GetCategorie?)



    
3. LRU Cache + exemplu (implementare)

In general, cand vorbim despre resurse computationale si servicii oferite, mereu apare cuvantul "optimizare". Motivul e simplu: Daca operatiile se efectueaza suficient de repede, avem clienti multumiti. De asemenea, reducand spatiul ocupat pe servere, ajungem sa platim mai putin pentru serviciile Cloud. Astfel, atunci cand rulam milioane de operatii zilnic, optimizarea unei operatii ce are loc des (de exemplu accesul la o resursa populara), poate avea un impact masiv asupra serviciilor oferite.

Intuitiv, produsele populare vor fi destul de des accesate, deci ne-ar placea sa oferim acces "privilegiat" acestora. Acesta paradigma se traduce intr-o modificare hardware. 
Asadar, pentru a implementa acest concept, vom simula un 'Least Recently Used Cache' pe server, care va retine id-ul produselor ce reprezinta ultimele accesari ale utilizatorilor.
Pentru o scurta explicatie asupra LRU Cache, click aici: https://www.youtube.com/watch?v=R5ON3iwx78M

Pentru a implementa cerinta, nu este nevoie sa stiti prea multe despre scopul si functionalitatile cache-ului intr-un sistem hardware, dar aici se afla o resursa utila in caz ca sunteti curiosi si vreti sa intelegeti mai bine puterea unui cache intr-un sistem de calcul: https://www.youtube.com/watch?time_continue=8&v=4McNhpkDNpQ&feature=emb_logo


Exemplu de functionare:
https://www.hackerrank.com/contests/justcode/challenges/lru-implementtion/problem



