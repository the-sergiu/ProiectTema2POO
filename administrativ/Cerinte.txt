
-- Cerinta initiala (de proiect); 5p/100

Implementati ierarhia de clase pentru produsele din magazin, pronind de la diagrama *diagrama UML*. Ce constructori, operatori si alte metode sunt necesare? Nu uitati de get-eri si set-eri! ?? Atentie, nu vor exista obiecte de tip Produs, ci doar subtipuri. ??

Acesta este un exercitiu pentru a va antrena in conceperea unei ierarhii de clase.

-- Tema propriu-zisa
( Sunt date fisierele .h, ce contin tipurile datelor si declararea functiilor necesare (pe care le vor implementa in .cpp) )

-- Implementati metodele descrise/necesare ierarhiei de produse. (Checker-ul verifica clasele)
Pentru implentarea corecta a claselor, de nota 5 (50/100 p)
* Pentru a testa clasele (de unele singure), commentati #include-ul claselor pe care nu intentionati sa le utilizati.

Initializati serverul. Listele de useri si produse sunt initializate folosind functii deja create, pentru a evita citirea din fisiere. Dupa acest pas, creati map-urile stocate pe server.

-- CERINTE
2. 2 tipuri de cautari/interogari/cerinte pentru manipularea datelor de pe server (folosind map-uri si listele de obiecte)
    a. George are nevoie de un aspirator nou. Fiind inainte de salariu, George se gandeste ca cea mai buna solutie ar fi sa achizitioneze un produs resigilat. Astfel, cautati in lista de produse aspiratoarele resigilate (**se va folosi dynamic cast, pentru a gasi produsele resigilate) si salvati in fisierul de output id-urile acestor produse.

    b. Utilizatorul Daniel Sima, avand ID-ul 342, vrea sa isi cumpere un telefon, avand un buget de 1500-2000 de lei. Fiind utilizator premium, el are vouchere personalizate. Va alege telefonul pe baza pretului (calculat pe baza reducerii de pret, daca este un produs redus, dar si prin aplicarea unei eventuale reduceri personale). Folosind map-ul de reduceri al lui Daniel, salvati in fisierul de output id-ul telefonului cu pretul cel mai mic (pret final, dupa aplicarea reducerilor). Atentie! Daniel nu vrea produse resigilate!

    c. Salvati in fisierul de output id-urile utilizatorilor nonpremium care au un cost de transport < 10 lei. 

    
3. LRU Cache + exemplu (implementare)

In general, cand vorbim despre resurse computationale si servicii oferite, mereu apare cuvantul "optimizare". Motivul e simplu: Daca operatiile se efectueaza suficient de repede, avem clienti multumiti. De asemenea, reducand spatiul ocupat pe servere, ajungem sa platim mai putin pentru serviciile Cloud. Astfel, atunci cand rulam milioane de operatii zilnic, optimizarea unei operatii ce are loc des (de exemplu accesul la o resursa populara), poate avea un impact masiv asupra serviciilor oferite.

Intuitiv, produsele populare vor fi destul de des accesate, deci ne-ar placea sa oferim acces "privilegiat" acestora. Acesta paradigma se traduce intr-o modificare hardware. 
Asadar, pentru a implementa acest concept, vom simula un 'Least Recently Used Cache' pe server, care va retine id-ul produselor ce reprezinta ultimele accesari ale utilizatorilor.
Pentru o scurta explicatie asupra LRU Cache, click aici: https://www.youtube.com/watch?v=R5ON3iwx78M

Pentru a implementa cerinta, nu este nevoie sa stiti prea multe despre scopul si functionalitatile cache-ului intr-un sistem hardware, dar aici se afla o resursa utila in caz ca sunteti curiosi si vreti sa intelegeti mai bine puterea unui cache intr-un sistem de calcul: https://www.youtube.com/watch?time_continue=8&v=4McNhpkDNpQ&feature=emb_logo


Exemplu de functionare:
https://www.hackerrank.com/contests/justcode/challenges/lru-implementtion/problem



